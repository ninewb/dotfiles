#!/usr/bin/env bash
# shellcheck disable=SC2155,SC1091
set -euo pipefail

# ==============================================================================
# Dotfiles bootstrap (Linux + macOS)
#
# Goals (minimal, fast, and reproducible):
#   - alacritty
#   - neovim
#   - tmux
#   - 1password-cli (op)
#   - kubectl
#   - k9s
#   - cargo (rustup)
#   - stow
#   - zsh
#
# Usage:
#   curl -fsSL https://raw.githubusercontent.com/ninewb/dotfiles/main/setup | bash
#   curl -fsSL "https://raw.githubusercontent.com/ninewb/dotfiles/main/setup?cachebust=$(date +%s)" | bash
#
# Optional env vars:
#   DOTFILES_REPO   (default: https://github.com/ninewb/dotfiles.git)
#   DOTFILES_DIR    (default: $HOME/.local/src/dotfiles)
#   STOW_PACKAGES   (default: "bin git neovim tmux zsh")
#   DO_STOW         (default: 1)  set to 0 to skip stow
#   INSTALL_GUI     (default: 1)  set to 0 to skip GUI apps (e.g., Alacritty on mac)
#   INSTALL_1PW      (default: 1) set to 0 to skip 1Password CLI
#   INSTALL_KUBECTL  (default: 1) set to 0 to skip kubectl
#   INSTALL_K9S      (default: 1) set to 0 to skip k9s
#   INSTALL_RUST     (default: 1) set to 0 to skip rustup/cargo
# ============================================================================== 

# -------- Pretty output --------
_hr() { printf '%*s\n' "${COLUMNS:-80}" '' | tr ' ' 'â”€'; }
_h() { printf "\n%s\n" "$( _hr )"; printf "%s\n" "$1"; printf "%s\n" "$( _hr )"; }

# -------- OS detection --------
OS="$(uname -s)"
ARCH="$(uname -m)"
IS_DARWIN=0
IS_LINUX=0
case "$OS" in
  Darwin) IS_DARWIN=1 ;;
  Linux)  IS_LINUX=1 ;;
  *) echo "Unsupported OS: $OS" >&2; exit 1 ;;
 esac

# -------- Defaults --------
: "${DOTFILES_REPO:=https://github.com/ninewb/dotfiles.git}"
: "${DOTFILES_DIR:=$HOME/.local/src/dotfiles}"
: "${STOW_PACKAGES:=bin git neovim tmux zsh}"
: "${DO_STOW:=1}"
: "${INSTALL_GUI:=1}"
: "${INSTALL_1PW:=1}"
: "${INSTALL_KUBECTL:=1}"
: "${INSTALL_K9S:=1}"
: "${INSTALL_RUST:=1}"

# -------- Helpers --------
has() { command -v "$1" >/dev/null 2>&1; }
need_cmd() { has "$1" || { echo "Missing required command: $1" >&2; return 1; }; }

# Homebrew helpers (avoid noisy "already installed" warnings)
# - If not installed: install
# - If installed and outdated: upgrade
# - If installed and up-to-date: skip
brew_ensure_formula() {
  local pkg="$1"
  if ! brew list --formula "$pkg" >/dev/null 2>&1; then
    echo "brew: install $pkg"
    brew install "$pkg"
    return 0
  fi

  if brew outdated --formula "$pkg" >/dev/null 2>&1; then
    # brew outdated exits 0 when there are outdated formulae matching
    if [[ -n "$(brew outdated --formula "$pkg")" ]]; then
      echo "brew: upgrade $pkg"
      brew upgrade "$pkg"
      return 0
    fi
  fi

  echo "brew: $pkg already up-to-date"
}

brew_ensure_cask() {
  local cask="$1"
  # casks are listed by token
  if ! brew list --cask "$cask" >/dev/null 2>&1; then
    echo "brew: install cask $cask"
    brew install --cask "$cask"
    return 0
  fi

  # For casks, `brew outdated --cask <name>` prints the name if outdated
  if [[ -n "$(brew outdated --cask "$cask" 2>/dev/null || true)" ]]; then
    echo "brew: upgrade cask $cask"
    brew upgrade --cask "$cask"
    return 0
  fi

  echo "brew: cask $cask already up-to-date"
}

# macOS brew path (Apple Silicon uses /opt/homebrew)
ensure_brew_in_path() {
  if [[ $IS_DARWIN -eq 1 ]]; then
    if [[ -x /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -x /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  fi
}

# -------- Zsh environment persistence (brew + cargo + sane config) --------
ensure_zsh_config() {
  _h "Configuring zsh environment (persist PATH, brew, cargo)"

  local zdot="$HOME/.config/zsh"
  mkdir -p "$zdot"

  # 1) Ensure ZDOTDIR is set early (zsh reads ~/.zshenv before anything else)
  local home_zshenv="$HOME/.zshenv"
  touch "$home_zshenv"
  if ! grep -q '^export ZDOTDIR=' "$home_zshenv"; then
    printf '\nexport ZDOTDIR="$HOME"/.config/zsh\n' >> "$home_zshenv"
  fi

  # 2) Fix cargo env source path (rustup installs ~/.cargo/env by default)
  #    Keep ZDOTDIR/.zshenv minimal: it runs for EVERY zsh (including non-interactive).
  local zdot_zshenv="$zdot/.zshenv"
  touch "$zdot_zshenv"

  # Remove old/bad cargo env source if present
  if grep -q '"\$HOME/\.local/lib/cargo/env"' "$zdot_zshenv" 2>/dev/null; then
    perl -0777 -i -pe 's/^.*\"\$HOME\/.local\/lib\/cargo\/env\".*\n//mg' "$zdot_zshenv" || true
  fi

  # Ensure rustup cargo env is sourced if available
  if ! grep -q '^\.[[:space:]]\+"\$HOME/\.cargo/env"' "$zdot_zshenv" 2>/dev/null; then
    printf '\n# rustup/cargo (installed by setup)\nif [[ -f "$HOME/.cargo/env" ]]; then\n  . "$HOME/.cargo/env"\nfi\n' >> "$zdot_zshenv"
  fi

# 3) Ensure interactive shells get brew + cargo PATH via sourced *.zsh files
#    Your ~/.config/zsh/.zshrc sources ~/.config/zsh/*.zsh; create those.
  # 3a) Ensure PATH includes user bins and Homebrew (covers cases where brew shellenv isn't loaded yet)
  #     This is sourced by ~/.config/zsh/.zshrc via the *.zsh loop.
  local path_zsh="$zdot/00-path.zsh"
  if [[ ! -f "$path_zsh" ]]; then
    cat > "$path_zsh" <<'EOF'
# Base PATH hygiene for interactive shells
# - Ensure user bins are present
# - Prefer Homebrew paths on macOS (Apple Silicon vs Intel)
# - De-duplicate entries

typeset -U path PATH

# User bins first (so your stowed scripts like `k8s` resolve)
path=(
  "$HOME/.local/bin"
  "$HOME/bin"
  "$HOME/.cargo/bin"
  $path
)

# Homebrew
if [[ -d /opt/homebrew/bin ]]; then
  path=(/opt/homebrew/bin /opt/homebrew/sbin $path)
elif [[ -d /usr/local/bin ]]; then
  path=(/usr/local/bin /usr/local/sbin $path)
fi

export PATH
EOF
  fi

  local brew_zsh="$zdot/10-homebrew.zsh"
  if [[ ! -f "$brew_zsh" ]]; then
    cat > "$brew_zsh" <<'EOF'
# Homebrew PATH for interactive shells
if [[ -x /opt/homebrew/bin/brew ]]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ -x /usr/local/bin/brew ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
fi
EOF
  fi

  local cargo_zsh="$zdot/20-cargo.zsh"
  if [[ ! -f "$cargo_zsh" ]]; then
    cat > "$cargo_zsh" <<'EOF'
# Cargo PATH for interactive shells
export PATH="$HOME/.cargo/bin:$PATH"
EOF
  fi

  # 4) Ensure ~/.config/zsh/.zshrc safely sources ~/.config/zsh/*.zsh
  #    - Avoid "no matches found" in zsh when no files match (use (N) nullglob)
  #    - Fix accidental absolute path like '/.config/zsh/*.zsh'
  local zshrc="$zdot/.zshrc"
  local desired_zshrc
  desired_zshrc=$'for config in "$HOME"/.config/zsh/*.zsh(N); do\n  [[ -r "$config" ]] && source "$config"\ndone\n'

  if [[ -f "$zshrc" ]]; then
    # If the file contains the old one-liner OR an incorrect absolute path, replace it.
    if grep -qE '^for[[:space:]]+config[[:space:]]*\(|/\.config/zsh/\*\.zsh' "$zshrc"; then
      printf '%s' "$desired_zshrc" > "$zshrc"
    else
      # If it doesn't already contain a *.zsh sourcing loop, append a managed loop.
      if ! grep -qE '\.config/zsh/\*\.zsh' "$zshrc"; then
        printf '\n%s' "$desired_zshrc" >> "$zshrc"
      fi
    fi
  else
    printf '%s' "$desired_zshrc" > "$zshrc"
  fi
}

# -------- Package installation --------
install_macos_packages() {
  _h "macOS: installing packages (Homebrew)"

  # If brew exists but isn't on PATH yet, load it first.
  ensure_brew_in_path

  if ! has brew; then
    echo "Homebrew not found in PATH. Checking standard locations..."
    if [[ -x /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -x /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  fi

  if ! has brew; then
    echo "Homebrew not found. Installing..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    ensure_brew_in_path
  fi

  brew update

  # Install/upgrade formulae individually to avoid noisy "already installed" warnings
  brew_ensure_formula git
  brew_ensure_formula stow
  brew_ensure_formula neovim
  brew_ensure_formula tmux
  brew_ensure_formula zsh
  brew_ensure_formula jq
  brew_ensure_formula fzf

  # Homebrew's python token currently maps to a versioned formula (e.g., python@3.x)
  # Ensuring "python" keeps it current.
  brew_ensure_formula python

  if [[ "$INSTALL_1PW" == "1" ]]; then
    brew_ensure_formula 1password-cli
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    brew_ensure_formula kubectl
  fi

  if [[ "$INSTALL_K9S" == "1" ]]; then
    brew_ensure_formula k9s
  fi

  if [[ "$INSTALL_GUI" == "1" ]]; then
    # Install Alacritty into user Applications directory to avoid sudo
    mkdir -p "$HOME/Applications"

    # Ensure cask token exists/updates, then move app into user Applications
    brew_ensure_cask alacritty

    # If brew installed into /Applications (some policies), copy/move isn't possible without sudo.
    # Using --appdir during install is the most reliable approach in managed environments.
    if [[ -d "$HOME/Applications/Alacritty.app" ]]; then
      :
    elif [[ -d "$(brew --prefix)/Caskroom/alacritty" ]]; then
      # Best-effort: if the app landed in the Caskroom, ensure it exists in ~/Applications.
      local app_src
      app_src="$(ls -1d "$(brew --prefix)"/Caskroom/alacritty/*/Alacritty.app 2>/dev/null | tail -n 1 || true)"
      if [[ -n "$app_src" ]]; then
        rsync -a "$app_src" "$HOME/Applications/" >/dev/null 2>&1 || true
      fi
    fi
  fi
}

install_linux_packages() {
  _h "Linux: installing packages (apt)"

  # Prefer Ubuntu/Debian apt-based flows.
  need_cmd apt-get

  sudo apt-get update -y

  # Keep existing packages current before installing new ones
  sudo apt-get upgrade -y
  sudo apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    git \
    gnupg \
    jq \
    locales \
    stow \
    tmux \
    neovim \
    zsh \
    fzf \
    python3 \
    python3-pip \
    k9s

  if [[ "$INSTALL_K9S" == "1" ]]; then
    if ! has k9s; then
      _h "Linux: installing k9s (fallback binary)"
      # Install latest k9s release binary (best-effort)
      local k9s_os="Linux"
      local k9s_arch="amd64"
      case "$(uname -m)" in
        x86_64|amd64) k9s_arch="amd64" ;;
        aarch64|arm64) k9s_arch="arm64" ;;
      esac

      local tmpdir
      tmpdir="$(mktemp -d)"
      (
        cd "$tmpdir"
        curl -fsSLO "https://github.com/derailed/k9s/releases/latest/download/k9s_${k9s_os}_${k9s_arch}.tar.gz"
        tar -xzf "k9s_${k9s_os}_${k9s_arch}.tar.gz"
        sudo install -m 0755 k9s /usr/local/bin/k9s
      )
      rm -rf "$tmpdir"
    fi
  fi

  # Alacritty availability varies by distro; try apt first.
  if [[ "$INSTALL_GUI" == "1" ]]; then
    if ! dpkg -s alacritty >/dev/null 2>&1; then
      sudo apt-get install -y alacritty || true
    fi
  fi

  if [[ "$INSTALL_1PW" == "1" ]]; then
    if ! has op; then
      _h "Linux: installing 1Password CLI (op)"
      # 1Password official repo install (Debian/Ubuntu)
      sudo mkdir -p /etc/apt/keyrings
      curl -fsSL https://downloads.1password.com/linux/keys/1password.asc \
        | sudo gpg --dearmor --yes -o /etc/apt/keyrings/1password-archive-keyring.gpg

      # Determine codename (fallback to jammy)
      local codename=""
      codename="$(. /etc/os-release && echo "${VERSION_CODENAME:-}")"
      if [[ -z "$codename" ]]; then codename="jammy"; fi

      echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/1password-archive-keyring.gpg] https://downloads.1password.com/linux/debian/$(dpkg --print-architecture) stable main" \
        | sudo tee /etc/apt/sources.list.d/1password.list >/dev/null

      sudo apt-get update -y
      sudo apt-get install -y 1password-cli
    fi
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    _h "Linux: ensuring kubectl"
    if ! has kubectl; then
      # Install latest stable kubectl
      local ver
      ver="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
      curl -fsSLO "https://dl.k8s.io/release/${ver}/bin/linux/amd64/kubectl"
      sudo install -m 0755 kubectl /usr/local/bin/kubectl
      rm -f kubectl
    fi
  fi
}

# -------- Rust / Cargo --------
install_rustup() {
  [[ "$INSTALL_RUST" == "1" ]] || return 0

  _h "Installing Rust (rustup/cargo)"

  if has cargo; then
    echo "cargo already present: $(command -v cargo)"
    return 0
  fi

  # rustup installs into ~/.cargo and ~/.rustup by default
  curl -fsSL https://sh.rustup.rs | sh -s -- -y --profile default --default-toolchain stable

  # Ensure current shell sees cargo for the rest of the script
  export PATH="$HOME/.cargo/bin:$PATH"
}

# -------- Zsh as default shell --------
ensure_zsh_default_shell() {
  _h "Ensuring zsh is the default shell"

  if ! has zsh; then
    echo "zsh not installed; skipping default shell change." >&2
    return 0
  fi

  # macOS: chsh is fine; Linux: may require sudo depending on environment
  local zsh_path="$(command -v zsh)"

  # Ensure zsh is listed in /etc/shells on Linux
  if [[ $IS_LINUX -eq 1 ]]; then
    if ! grep -qx "$zsh_path" /etc/shells; then
      echo "$zsh_path" | sudo tee -a /etc/shells >/dev/null
    fi
  fi

  if [[ "${SHELL:-}" != "$zsh_path" ]]; then
    echo "Changing default shell to: $zsh_path"
    chsh -s "$zsh_path" || true
  fi
}

# -------- Dotfiles clone + stow --------
setup_dotfiles() {
  _h "Cloning dotfiles"

  mkdir -p "$(dirname "$DOTFILES_DIR")"

  if [[ -d "$DOTFILES_DIR/.git" ]]; then
    echo "Dotfiles already cloned: $DOTFILES_DIR"
  else
    git clone "$DOTFILES_REPO" "$DOTFILES_DIR"
  fi

  if [[ "$DO_STOW" == "1" ]]; then
    _h "Stowing packages: $STOW_PACKAGES"
    ( cd "$DOTFILES_DIR" && stow $STOW_PACKAGES -t "$HOME" )
  else
    echo "Skipping stow (DO_STOW=0)"
  fi

  # Ensure ZDOTDIR is consistent with your repo expectation
  # Only add if not already present
  local zshenv=""
  if [[ $IS_DARWIN -eq 1 ]]; then
    zshenv="$HOME/.zshenv"
  else
    # System zshenv is common on Linux; keep user-scoped and non-root
    zshenv="$HOME/.zshenv"
  fi

  if [[ ! -f "$zshenv" ]] || ! grep -q 'export ZDOTDIR=' "$zshenv"; then
    echo 'export ZDOTDIR="$HOME"/.config/zsh' >> "$zshenv"
  fi
}

# -------- Alacritty config sanity --------
post_checks() {
  _h "Post-install checks"

  echo "OS: $OS ($ARCH)"

  echo "PATH: $PATH"
  if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
    echo "Note: $HOME/.local/bin is not on PATH (your stowed bin scripts may not resolve)." >&2
  fi

  for c in git stow nvim tmux zsh python3 pip3 kubectl k9s; do
    if has "$c"; then
      echo "OK: $c -> $(command -v "$c")"
    else
      echo "MISSING: $c" >&2
    fi
  done

  if [[ "$INSTALL_1PW" == "1" ]]; then
    if has op; then
      echo "OK: op -> $(command -v op)"
      echo "Note: run 'op signin' manually to authenticate."
    else
      echo "MISSING: op (1Password CLI)" >&2
    fi
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    if has kubectl; then
      echo "OK: kubectl -> $(command -v kubectl)"
    else
      echo "MISSING: kubectl" >&2
    fi
  fi

  if [[ "$INSTALL_RUST" == "1" ]]; then
    if has cargo; then
      echo "OK: cargo -> $(command -v cargo)"
    else
      echo "MISSING: cargo" >&2
    fi
  fi

  if [[ "$INSTALL_GUI" == "1" ]]; then
    if has alacritty; then
      echo "OK: alacritty -> $(command -v alacritty)"
    elif [[ -d "$HOME/Applications/Alacritty.app" ]]; then
      echo "OK: Alacritty.app found in $HOME/Applications"
    elif [[ -d "/Applications/Alacritty.app" ]]; then
      echo "OK: Alacritty.app found in /Applications"
    else
      echo "MISSING: alacritty" >&2
    fi
  fi

  echo
  echo "Next steps:"
  echo "  1) Open a new terminal session (zsh)"
  echo "  2) (Optional) Authenticate 1Password: op signin"
  echo "  3) (Optional) Configure kubectl access (kubeconfig)"
}

main() {
  _h "Bootstrapping terminal environment"

  if [[ $IS_DARWIN -eq 1 ]]; then
    install_macos_packages
  else
    install_linux_packages
  fi

  install_rustup
  setup_dotfiles
  ensure_zsh_config
  ensure_zsh_default_shell
  post_checks
}

main "$@"