#!/usr/bin/env bash
# shellcheck disable=SC2155,SC1091
set -euo pipefail

# ==============================================================================
# Dotfiles bootstrap (Linux + macOS)
#
# Facts:
#   - kitty
#   - neovim
#   - tmux
#   - tmux plugin manager (tpm)
#   - nerd fonts (for glyphs/icons in tmux and prompt)
#   - 1password-cli (op)
#   - kubectl
#   - k9s
#   - cargo (rustup)
#   - stow
#   - zsh
#   - starship (prompt)
#
# Usage:
#   curl -fsSL https://raw.githubusercontent.com/ninewb/dotfiles/main/setup | bash
#   curl -fsSL "https://raw.githubusercontent.com/ninewb/dotfiles/main/setup?cachebust=$(date +%s)" | bash
#   ./setup --apt-upgrade true
#   ./setup --install-gui false
#   ./setup --install-claude true
#   ./setup --stow-packages "bin git neovim tmux zsh"
#
# ============================================================================== 

# -------- Pretty output --------
_hr() { printf '%*s\n' "${COLUMNS:-80}" '' | tr ' ' 'â”€'; }
_h() { printf "\n%s\n" "$( _hr )"; printf "%s\n" "$1"; printf "%s\n" "$( _hr )"; }

# -------- OS detection --------
OS="$(uname -s)"
ARCH="$(uname -m)"
IS_DARWIN=0
IS_LINUX=0
case "$OS" in
  Darwin) IS_DARWIN=1 ;;
  Linux)  IS_LINUX=1 ;;
  *) echo "Unsupported OS: $OS" >&2; exit 1 ;;
 esac

# -------- Defaults --------
: "${DOTFILES_REPO:=https://github.com/ninewb/dotfiles.git}"
: "${DOTFILES_DIR:=$HOME/.local/src/dotfiles}"
: "${STOW_PACKAGES:=bin git neovim tmux zsh}"
: "${DO_STOW:=1}"
: "${DO_APT_UPGRADE:=0}"
: "${INSTALL_GUI:=1}"
: "${INSTALL_CLAUDE:=1}"
: "${INSTALL_FONTS:=1}"
: "${INSTALL_1PW:=1}"
: "${INSTALL_KUBECTL:=1}"
: "${INSTALL_K9S:=1}"
: "${INSTALL_RUST:=1}"
: "${INSTALL_STARSHIP:=1}"
: "${INSTALL_FZF:=1}"

# -------- CLI argument parsing --------
print_help() {
  cat <<'EOF'
Dotfiles setup

Usage:
  ./setup [options]

Options:
  --dotfiles-repo <url>
  --dotfiles-dir <path>
  --stow-packages "..."
  --stow <true|false>
  --apt-upgrade <true|false>
  --install-gui <true|false>
  --install-fonts <true|false>
  --install-1pw <true|false>
  --install-kubectl <true|false>
  --install-k9s <true|false>
  --install-rust <true|false>
  --install-starship <true|false>
  --install-fzf <true|false>
  --install-claude <true|false>
  --help

Environment variables (optional):
  DOTFILES_REPO        (default: https://github.com/ninewb/dotfiles.git)
  DOTFILES_DIR         (default: $HOME/.local/src/dotfiles)
  STOW_PACKAGES        (default: "bin git neovim tmux zsh")
  DO_STOW              (default: 1)  set to 0 to skip stow
  DO_APT_UPGRADE        (default: 0)  set to 1 to run apt-get upgrade during bootstrap
  INSTALL_GUI          (default: 1)  set to 0 to skip GUI apps (e.g., Kitty on mac)
  INSTALL_FONTS        (default: 1)  set to 0 to skip Nerd Fonts installation
  INSTALL_1PW          (default: 1)  set to 0 to skip 1Password CLI
  INSTALL_KUBECTL      (default: 1)  set to 0 to skip kubectl
  INSTALL_K9S          (default: 1)  set to 0 to skip k9s
  INSTALL_RUST         (default: 1)  set to 0 to skip rustup/cargo
  INSTALL_STARSHIP     (default: 1)  set to 0 to skip starship
  INSTALL_FZF          (default: 1)  set to 0 to skip fzf
  INSTALL_CLAUDE        (default: 1)  set to 0 to skip Claude install

Examples:
  DO_APT_UPGRADE=1 ./setup
  INSTALL_GUI=0 ./setup
  ./setup --apt-upgrade true --install-gui false

Notes:
  - CLI switches override defaults and environment variables (if both are used).
  - Boolean values accept: true/false, 1/0, yes/no, on/off.
EOF
}

_normalize_bool() {
  local v="${1:-}"
  v="${v,,}"
  case "$v" in
    1|true|yes|y|on) echo "1" ;;
    0|false|no|n|off) echo "0" ;;
    *) echo "" ;;
  esac
}

_set_bool_var() {
  local name="$1"
  local raw="$2"
  local norm
  norm="$(_normalize_bool "$raw")"
  if [[ -z "$norm" ]]; then
    echo "Invalid boolean for $name: '$raw'" >&2
    exit 2
  fi
  printf -v "$name" '%s' "$norm"
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        print_help
        exit 0
        ;;

      --dotfiles-repo)
        [[ $# -ge 2 ]] || { echo "--dotfiles-repo requires a value" >&2; exit 2; }
        DOTFILES_REPO="$2"; shift 2 ;;
      --dotfiles-dir)
        [[ $# -ge 2 ]] || { echo "--dotfiles-dir requires a value" >&2; exit 2; }
        DOTFILES_DIR="$2"; shift 2 ;;
      --stow-packages)
        [[ $# -ge 2 ]] || { echo "--stow-packages requires a value" >&2; exit 2; }
        STOW_PACKAGES="$2"; shift 2 ;;

      --stow)
        [[ $# -ge 2 ]] || { echo "--stow requires true|false" >&2; exit 2; }
        _set_bool_var DO_STOW "$2"; shift 2 ;;
      --apt-upgrade)
        [[ $# -ge 2 ]] || { echo "--apt-upgrade requires true|false" >&2; exit 2; }
        _set_bool_var DO_APT_UPGRADE "$2"; shift 2 ;;

      --install-gui)
        [[ $# -ge 2 ]] || { echo "--install-gui requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_GUI "$2"; shift 2 ;;
      --install-fonts)
        [[ $# -ge 2 ]] || { echo "--install-fonts requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_FONTS "$2"; shift 2 ;;
      --install-1pw)
        [[ $# -ge 2 ]] || { echo "--install-1pw requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_1PW "$2"; shift 2 ;;
      --install-kubectl)
        [[ $# -ge 2 ]] || { echo "--install-kubectl requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_KUBECTL "$2"; shift 2 ;;
      --install-k9s)
        [[ $# -ge 2 ]] || { echo "--install-k9s requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_K9S "$2"; shift 2 ;;
      --install-rust)
        [[ $# -ge 2 ]] || { echo "--install-rust requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_RUST "$2"; shift 2 ;;
      --install-starship)
        [[ $# -ge 2 ]] || { echo "--install-starship requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_STARSHIP "$2"; shift 2 ;;
      --install-fzf)
        [[ $# -ge 2 ]] || { echo "--install-fzf requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_FZF "$2"; shift 2 ;;
      --install-claude)
        [[ $# -ge 2 ]] || { echo "--install-claude requires true|false" >&2; exit 2; }
        _set_bool_var INSTALL_CLAUDE "$2"; shift 2 ;;

      --no-stow) DO_STOW=0; shift ;;
      --no-apt-upgrade) DO_APT_UPGRADE=0; shift ;;
      --no-install-gui) INSTALL_GUI=0; shift ;;
      --no-install-fonts) INSTALL_FONTS=0; shift ;;
      --no-install-1pw) INSTALL_1PW=0; shift ;;
      --no-install-kubectl) INSTALL_KUBECTL=0; shift ;;
      --no-install-k9s) INSTALL_K9S=0; shift ;;
      --no-install-rust) INSTALL_RUST=0; shift ;;
      --no-install-starship) INSTALL_STARSHIP=0; shift ;;
      --no-install-fzf) INSTALL_FZF=0; shift ;;
      --no-install-claude) INSTALL_CLAUDE=0; shift ;;

      *)
        echo "Unknown option: $1" >&2
        echo "Run: ./setup --help" >&2
        exit 2
        ;;
    esac
  done
}

# -------- Helpers --------
has() { command -v "$1" >/dev/null 2>&1; }
need_cmd() { has "$1" || { echo "Missing required command: $1" >&2; return 1; }; }

brew_ensure_formula() {
  local pkg="$1"
  if ! brew list --formula "$pkg" >/dev/null 2>&1; then
    echo "brew: install $pkg"
    brew install "$pkg"
    return 0
  fi

  local outdated
  outdated="$(brew outdated --formula "$pkg" 2>/dev/null || true)"
  if [[ -n "$outdated" ]]; then
    echo "brew: upgrade $pkg"
    brew upgrade "$pkg"
    return 0
  fi

  echo "brew: $pkg already up-to-date"
}

brew_ensure_cask() {
  local cask="$1"
  # casks are listed by token
  if ! brew list --cask "$cask" >/dev/null 2>&1; then
    echo "brew: install cask $cask"
    brew install --cask "$cask"
    return 0
  fi

  # For casks, `brew outdated --cask <name>` prints the name if outdated
  if [[ -n "$(brew outdated --cask "$cask" 2>/dev/null || true)" ]]; then
    echo "brew: upgrade cask $cask"
    brew upgrade --cask "$cask"
    return 0
  fi

  echo "brew: cask $cask already up-to-date"
}

ensure_brew_in_path() {
  if [[ $IS_DARWIN -eq 1 ]]; then
    if [[ -x /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -x /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  elif [[ $IS_LINUX -eq 1 ]]; then
    if [[ -x /home/linuxbrew/.linuxbrew/bin/brew ]]; then
      eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
    fi
  fi
}

# -------- Nerd Fonts installation --------
install_nerd_fonts() {
  [[ "${INSTALL_FONTS:-1}" == "1" ]] || return 0

  _h "Installing Nerd Fonts (glyphs/icons for tmux + prompt)"

  if [[ $IS_DARWIN -eq 1 ]]; then
    ensure_brew_in_path
    if ! has brew; then
      echo "Homebrew not found; cannot install fonts automatically." >&2
      return 0
    fi

    brew tap homebrew/cask-fonts >/dev/null 2>&1 || true

    # Widely compatible Nerd Font
    brew_ensure_cask font-jetbrains-mono-nerd-font

  elif [[ $IS_LINUX -eq 1 ]]; then
    local font_name="JetBrainsMono"
    local nf_version="3.2.1"
    local url="https://github.com/ryanoasis/nerd-fonts/releases/download/v${nf_version}/${font_name}.zip"

    need_cmd curl
    need_cmd unzip

    local font_dir="$HOME/.local/share/fonts"
    mkdir -p "$font_dir"

    local tmpdir
    tmpdir="$(mktemp -d)"

    echo "Downloading Nerd Font: ${font_name} (v${nf_version})"
    (
      cd "$tmpdir"
      curl -fsSLo "${font_name}.zip" "$url"
      unzip -o "${font_name}.zip" -d "$tmpdir" >/dev/null

      find "$tmpdir" -maxdepth 1 -type f \( -name '*.ttf' -o -name '*.otf' \) -print0 \
        | xargs -0 -I{} cp -f "{}" "$font_dir/"
    )

    rm -rf "$tmpdir"

    if has fc-cache; then
      fc-cache -f "$font_dir" >/dev/null 2>&1 || true
    else
      echo "Note: fc-cache not found. Install fontconfig and run: fc-cache -f" >&2
    fi
  fi
}

# -------- Claude CLI installation --------
install_claude() {
  [[ "${INSTALL_CLAUDE:-1}" == "1" ]] || return 0

  _h "Installing Claude (claude.ai)"

  need_cmd curl

  # Best-effort: avoid reinstall if already present
  if has claude; then
    echo "claude already present: $(command -v claude)"
    return 0
  fi

  # claude.ai installer is intended to be cross-platform (macOS + Linux)
  # Run in a subshell to avoid polluting current shell env.
  ( curl -fsSL https://claude.ai/install.sh | bash )
}

# -------- Zsh environment persistence (brew + cargo + sane config) --------
ensure_zsh_config() {
  _h "Configuring zsh environment (persist PATH, brew, cargo)"

  local zdot="$HOME/.config/zsh"
  mkdir -p "$zdot"

  local home_zshenv="$HOME/.zshenv"
  touch "$home_zshenv"
  if ! grep -q '^export ZDOTDIR=' "$home_zshenv"; then
    printf '\nexport ZDOTDIR="$HOME"/.config/zsh\n' >> "$home_zshenv"
  fi

  local zdot_zshenv="$zdot/.zshenv"
  touch "$zdot_zshenv"

  # Remove old/bad cargo env source if present
  if grep -q '"\$HOME/\.local/lib/cargo/env"' "$zdot_zshenv" 2>/dev/null; then
    perl -0777 -i -pe 's/^.*\"\$HOME\/.local\/lib\/cargo\/env\".*\n//mg' "$zdot_zshenv" || true
  fi

  # Ensure rustup cargo env is sourced if available
  if ! grep -q '^\.[[:space:]]\+"\$HOME/\.cargo/env"' "$zdot_zshenv" 2>/dev/null; then
    printf '\n# rustup/cargo (installed by setup)\nif [[ -f "$HOME/.cargo/env" ]]; then\n  . "$HOME/.cargo/env"\nfi\n' >> "$zdot_zshenv"
  fi

  # Ensure PATH basics are present for every zsh (including non-interactive shells)
  # Keep this simple and idempotent.
  local marker_begin="# >>> dotfiles PATH >>>"
  local marker_end="# <<< dotfiles PATH <<<"

  # Remove existing managed PATH block if present
  perl -0777 -i -pe "s/\n?\Q${marker_begin}\E.*?\Q${marker_end}\E\n?/\n/sg" "$zdot_zshenv" 2>/dev/null || true

  cat >> "$zdot_zshenv" <<'EOF'

# >>> dotfiles PATH >>>
# Base PATH hygiene (runs for every zsh)
typeset -U path PATH

# User bins first (stow targets ~/.local/bin)
path=(
  "$HOME/.local/bin"
  "$HOME/bin"
  "$HOME/.cargo/bin"
  $path
)

# System bins
path=(/usr/local/bin /usr/local/sbin $path)

# Homebrew / Linuxbrew
if [[ -d /opt/homebrew/bin ]]; then
  path=(/opt/homebrew/bin /opt/homebrew/sbin $path)
elif [[ -d /usr/local/bin ]]; then
  :
elif [[ -d /home/linuxbrew/.linuxbrew/bin ]]; then
  path=(/home/linuxbrew/.linuxbrew/bin /home/linuxbrew/.linuxbrew/sbin $path)
fi

export PATH
# <<< dotfiles PATH <<<
EOF

  local path_zsh="$zdot/00-path.zsh"
  if [[ ! -f "$path_zsh" ]]; then
    cat > "$path_zsh" <<'EOF'
# Base PATH hygiene for interactive shells
# - Ensure user bins are present
# - Prefer Homebrew paths on macOS (Apple Silicon vs Intel)
# - De-duplicate entries

typeset -U path PATH

# User bins first (so your stowed scripts like `k8s` resolve)
path=(
  "$HOME/.local/bin"
  "$HOME/bin"
  "$HOME/.cargo/bin"
  $path
)

# Homebrew / Linuxbrew
if [[ -d /opt/homebrew/bin ]]; then
  path=(/opt/homebrew/bin /opt/homebrew/sbin $path)
elif [[ -d /home/linuxbrew/.linuxbrew/bin ]]; then
  path=(/home/linuxbrew/.linuxbrew/bin /home/linuxbrew/.linuxbrew/sbin $path)
elif [[ -d /usr/local/bin ]]; then
  path=(/usr/local/bin /usr/local/sbin $path)
fi

export PATH
EOF
  fi

  local brew_zsh="$zdot/10-homebrew.zsh"
  if [[ ! -f "$brew_zsh" ]]; then
    cat > "$brew_zsh" <<'EOF'
# Homebrew PATH for interactive shells
if [[ -x /opt/homebrew/bin/brew ]]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ -x /usr/local/bin/brew ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
fi
EOF
  fi

  local cargo_zsh="$zdot/20-cargo.zsh"
  if [[ ! -f "$cargo_zsh" ]]; then
    cat > "$cargo_zsh" <<'EOF'
# Cargo PATH for interactive shells
export PATH="$HOME/.cargo/bin:$PATH"
EOF
  fi

  local zprofile="$zdot/.zprofile"
  if [[ ! -f "$zprofile" ]]; then
    cat > "$zprofile" <<'EOF'
# Login shell environment
if [[ -x /opt/homebrew/bin/brew ]]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ -x /usr/local/bin/brew ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
elif [[ -x /home/linuxbrew/.linuxbrew/bin/brew ]]; then
  eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi
EOF
  fi

  local zshrc="$zdot/.zshrc"
  local desired_zshrc
  desired_zshrc=$'for config in "$HOME"/.config/zsh/*.zsh(N); do\n  [[ -r "$config" ]] && source "$config"\ndone\n'

  if [[ -f "$zshrc" ]]; then
    # If the file contains the old one-liner OR an incorrect absolute path, replace it.
    if grep -qE '^for[[:space:]]+config[[:space:]]*\(|/\.config/zsh/\*\.zsh' "$zshrc"; then
      printf '%s' "$desired_zshrc" > "$zshrc"
    else
      # If it doesn't already contain a *.zsh sourcing loop, append a managed loop.
      if ! grep -qE '\.config/zsh/\*\.zsh' "$zshrc"; then
        printf '\n%s' "$desired_zshrc" >> "$zshrc"
      fi
    fi
  else
    printf '%s' "$desired_zshrc" > "$zshrc"
  fi
}

# -------- Package installation --------
install_macos_packages() {
  _h "macOS: installing packages (Homebrew)"

  # If brew exists but isn't on PATH yet, load it first.
  ensure_brew_in_path

  if ! has brew; then
    echo "Homebrew not found in PATH. Checking standard locations..."
    if [[ -x /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -x /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  fi

  if ! has brew; then
    echo "Homebrew not found. Installing..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    ensure_brew_in_path
  fi

  brew update

  # Install/upgrade formulae individually to avoid noisy "already installed" warnings
  brew_ensure_formula git
  brew_ensure_formula stow
  brew_ensure_formula neovim
  brew_ensure_formula tmux
  brew_ensure_formula zsh
  brew_ensure_formula jq
  if [[ "$INSTALL_FZF" == "1" ]]; then
    brew_ensure_formula fzf
  fi
  if [[ "$INSTALL_STARSHIP" == "1" ]]; then
    brew_ensure_formula starship
  fi

  # Homebrew's python token currently maps to a versioned formula (e.g., python@3.x)
  # Ensuring "python" keeps it current.
  brew_ensure_formula python

  if [[ "$INSTALL_1PW" == "1" ]]; then
    brew_ensure_formula 1password-cli
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    brew_ensure_formula kubectl
  fi

  if [[ "$INSTALL_K9S" == "1" ]]; then
    brew_ensure_formula k9s
  fi

  if [[ "$INSTALL_GUI" == "1" ]]; then
    # Install Kitty (terminal emulator)
    brew_ensure_cask kitty

    # Best-effort: ensure app exists in standard macOS locations
    if [[ -d "$HOME/Applications/Kitty.app" ]]; then
      :
    elif [[ -d "/Applications/Kitty.app" ]]; then
      :
    elif [[ -d "$(brew --prefix)/Caskroom/kitty" ]]; then
      local app_src
      app_src="$(ls -1d "$(brew --prefix)"/Caskroom/kitty/*/Kitty.app 2>/dev/null | tail -n 1 || true)"
      if [[ -n "$app_src" ]]; then
        mkdir -p "$HOME/Applications"
        rsync -a "$app_src" "$HOME/Applications/" >/dev/null 2>&1 || true
      fi
    fi
  fi
}

install_linux_packages() {
  _h "Linux: installing packages (apt)"

  # Prefer Ubuntu/Debian apt-based flows.
  need_cmd apt-get

  sudo apt-get update -y

  # Optional: full upgrade can be slow/noisy on fresh machines; keep it opt-in.
  if [[ "${DO_APT_UPGRADE:-0}" == "1" ]]; then
    sudo apt-get upgrade -y
  fi
  sudo apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    unzip \
    fontconfig \
    git \
    gnupg \
    jq \
    locales \
    stow \
    tmux \
    neovim \
    zsh \
    python3 \
    python3-pip

  if [[ "$INSTALL_FZF" == "1" ]]; then
    sudo apt-get install -y --no-install-recommends fzf || true
    if ! has fzf; then
      _h "Linux: installing fzf (fallback git install)"
      # Best-effort fallback: install fzf from git into ~/.fzf
      need_cmd git
      local fzf_dir="$HOME/.fzf"
      if [[ -d "$fzf_dir/.git" ]]; then
        ( cd "$fzf_dir" && git pull --ff-only ) || true
      else
        git clone --depth 1 https://github.com/junegunn/fzf.git "$fzf_dir" || true
      fi
      if [[ -x "$fzf_dir/install" ]]; then
        "$fzf_dir/install" --bin --no-update-rc --no-key-bindings --no-completion || true
        # Add ~/.fzf/bin for the remainder of the script
        export PATH="$fzf_dir/bin:$PATH"
      fi
    fi
  fi

  if [[ "$INSTALL_STARSHIP" == "1" ]]; then
    sudo apt-get install -y --no-install-recommends starship || true
  fi

  if [[ "$INSTALL_K9S" == "1" ]]; then
    sudo apt-get install -y --no-install-recommends k9s || true
  fi

  if [[ "$INSTALL_STARSHIP" == "1" ]]; then
    if ! has starship; then
      _h "Linux: installing starship (fallback script)"
      curl -fsSL https://starship.rs/install.sh | sh -s -- -y
    fi
  fi

  if [[ "$INSTALL_K9S" == "1" ]]; then
    if ! has k9s; then
      _h "Linux: installing k9s (fallback binary)"
      # Install latest k9s release binary (best-effort)
      local k9s_os="Linux"
      local k9s_arch="amd64"
      case "$(uname -m)" in
        x86_64|amd64) k9s_arch="amd64" ;;
        aarch64|arm64) k9s_arch="arm64" ;;
      esac

      local tmpdir
      tmpdir="$(mktemp -d)"
      (
        cd "$tmpdir"
        curl -fsSLO "https://github.com/derailed/k9s/releases/latest/download/k9s_${k9s_os}_${k9s_arch}.tar.gz"
        tar -xzf "k9s_${k9s_os}_${k9s_arch}.tar.gz"
        sudo install -m 0755 k9s /usr/local/bin/k9s
      )
      rm -rf "$tmpdir"
    fi
  fi

  # Kitty availability varies by distro; try apt first.
  if [[ "$INSTALL_GUI" == "1" ]]; then
    if ! dpkg -s kitty >/dev/null 2>&1; then
      sudo apt-get install -y kitty || true
    fi
  fi

  if [[ "$INSTALL_1PW" == "1" ]]; then
    if ! has op; then
      _h "Linux: installing 1Password CLI (op)"
      # 1Password official repo install (Debian/Ubuntu)
      sudo mkdir -p /etc/apt/keyrings
      curl -fsSL https://downloads.1password.com/linux/keys/1password.asc \
        | sudo gpg --dearmor --yes -o /etc/apt/keyrings/1password-archive-keyring.gpg

      # Determine codename (fallback to jammy)
      local codename=""
      codename="$(. /etc/os-release && echo "${VERSION_CODENAME:-}")"
      if [[ -z "$codename" ]]; then codename="jammy"; fi

      echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/1password-archive-keyring.gpg] https://downloads.1password.com/linux/debian/$(dpkg --print-architecture) stable main" \
        | sudo tee /etc/apt/sources.list.d/1password.list >/dev/null

      sudo apt-get update -y
      sudo apt-get install -y 1password-cli
    fi
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    _h "Linux: ensuring kubectl"
    if ! has kubectl; then
      # Install latest stable kubectl
      local ver
      ver="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
      curl -fsSLO "https://dl.k8s.io/release/${ver}/bin/linux/amd64/kubectl"
      sudo install -m 0755 kubectl /usr/local/bin/kubectl
      rm -f kubectl
    fi
  fi
}

# -------- Rust / Cargo --------
install_rustup() {
  [[ "$INSTALL_RUST" == "1" ]] || return 0

  _h "Installing Rust (rustup/cargo)"

  if has cargo; then
    echo "cargo already present: $(command -v cargo)"
    return 0
  fi

  # rustup installs into ~/.cargo and ~/.rustup by default
  curl -fsSL https://sh.rustup.rs | sh -s -- -y --profile default --default-toolchain stable

  # Ensure current shell sees cargo for the rest of the script
  export PATH="$HOME/.cargo/bin:$PATH"
}

# -------- Zsh as default shell --------
ensure_zsh_default_shell() {
  _h "Ensuring zsh is the default shell"

  if ! has zsh; then
    echo "zsh not installed; skipping default shell change." >&2
    return 0
  fi

  # macOS: chsh is fine; Linux: may require sudo depending on environment
  local zsh_path="$(command -v zsh)"

  # Ensure zsh is listed in /etc/shells on Linux
  if [[ $IS_LINUX -eq 1 ]]; then
    if ! grep -qx "$zsh_path" /etc/shells; then
      echo "$zsh_path" | sudo tee -a /etc/shells >/dev/null
    fi
  fi

  if [[ "${SHELL:-}" != "$zsh_path" ]]; then
    echo "Changing default shell to: $zsh_path"
    chsh -s "$zsh_path" || true
  fi
}

ensure_tmux_tpm() {
  _h "Ensuring tmux plugin manager (tpm)"

  local tpm_dir="$HOME/.tmux/plugins/tpm"

  # Ensure parent dir exists
  mkdir -p "$(dirname "$tpm_dir")"

  # Clone or update
  if [[ -d "$tpm_dir/.git" ]]; then
    echo "tpm already present: $tpm_dir"
    ( cd "$tpm_dir" && git pull --ff-only ) || echo "Warning: unable to update tpm; continuing" >&2
  else
    echo "Installing tpm to: $tpm_dir"
    git clone https://github.com/tmux-plugins/tpm "$tpm_dir"
  fi

  # Best-effort: if tmux is running, install plugins immediately; otherwise user can do it later.
  if has tmux; then
    if tmux list-sessions >/dev/null 2>&1; then
      echo "tmux session detected; attempting to install plugins via tpm..."
      "$tpm_dir/bin/install_plugins" || true
      "$tpm_dir/bin/update_plugins" all || true
    else
      echo "No tmux session detected. After starting tmux, install plugins with: prefix + I"
    fi
  fi
}

# -------- Dotfiles clone + stow --------
setup_dotfiles() {
  _h "Cloning dotfiles"

  mkdir -p "$(dirname "$DOTFILES_DIR")"

  if [[ -d "$DOTFILES_DIR/.git" ]]; then
    echo "Dotfiles already cloned: $DOTFILES_DIR"
    echo "Updating dotfiles (git pull --ff-only)..."
    ( cd "$DOTFILES_DIR" && git pull --ff-only ) || echo "Warning: unable to fast-forward update dotfiles repo; continuing" >&2
  else
    git clone "$DOTFILES_REPO" "$DOTFILES_DIR"
  fi

  # Print current dotfiles revision for troubleshooting
  ( cd "$DOTFILES_DIR" && echo "Dotfiles revision: $(git rev-parse --short HEAD)" ) || true

  if [[ "$DO_STOW" == "1" ]]; then
    _h "Stowing packages (skipping missing): $STOW_PACKAGES"

    # Stow each package individually; skip if the package directory does not exist
    local pkg
    for pkg in $STOW_PACKAGES; do
      if [[ -d "$DOTFILES_DIR/$pkg" ]]; then
        echo "stow: $pkg"
        # Use --restow so reruns refresh symlinks; use -v to show conflicts clearly.
        ( cd "$DOTFILES_DIR" && stow -v --restow "$pkg" -t "$HOME" ) || echo "stow: package '$pkg' had conflicts; skipping" >&2
      else
        echo "stow: skipping missing package '$pkg' (no directory at $DOTFILES_DIR/$pkg)" >&2
      fi
    done

    # Quick verification (helps diagnose stow conflicts)
    if [[ -d "$DOTFILES_DIR/zsh/.config/zsh" ]]; then
      echo "Repo zsh files:" 
      ls -la "$DOTFILES_DIR/zsh/.config/zsh" || true
    fi

    echo "Home zsh config after stow:" 
    ls -la "$HOME/.config/zsh" || true
  else
    echo "Skipping stow (DO_STOW=0)"
  fi

  # Ensure ZDOTDIR is consistent with your repo expectation
  # Only add if not already present
  local zshenv=""
  if [[ $IS_DARWIN -eq 1 ]]; then
    zshenv="$HOME/.zshenv"
  else
    # System zshenv is common on Linux; keep user-scoped and non-root
    zshenv="$HOME/.zshenv"
  fi

  if [[ ! -f "$zshenv" ]] || ! grep -q 'export ZDOTDIR=' "$zshenv"; then
    echo 'export ZDOTDIR="$HOME"/.config/zsh' >> "$zshenv"
  fi
}

# -------- Alacritty config sanity --------
post_checks() {
  _h "Post-install checks"

  echo "OS: $OS ($ARCH)"

  echo "PATH: $PATH"
  if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
    echo "Note: $HOME/.local/bin is not on PATH (your stowed bin scripts may not resolve)." >&2
  fi

  local -a checks
  checks=(git stow nvim tmux zsh jq fzf python3 pip3)

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    checks+=(kubectl)
  fi

  if [[ "$INSTALL_K9S" == "1" ]]; then
    checks+=(k9s)
  fi

  if [[ "$INSTALL_STARSHIP" == "1" ]]; then
    checks+=(starship)
  fi

  if [[ "$INSTALL_1PW" == "1" ]]; then
    checks+=(op)
  fi

  if [[ "$INSTALL_CLAUDE" == "1" ]]; then
    checks+=(claude)
  fi

  if [[ "$INSTALL_GUI" == "1" ]]; then
    checks+=(kitty)
  fi

  local c
  for c in "${checks[@]}"; do
    if has "$c"; then
      echo "OK: $c -> $(command -v "$c")"
    else
      echo "MISSING: $c" >&2
    fi
  done

  # TPM check
  if [[ -x "$HOME/.tmux/plugins/tpm/tpm" ]]; then
    echo "OK: tpm -> $HOME/.tmux/plugins/tpm/tpm"
  else
    echo "MISSING: tpm (tmux plugin manager)" >&2
  fi

  # Nerd Fonts check (best-effort)
  if has fc-list; then
    if fc-list | grep -qi "JetBrainsMono Nerd Font"; then
      echo "OK: Nerd Font detected (JetBrainsMono Nerd Font)"
    else
      echo "Note: Nerd Font not detected via fc-list. If icons look like boxes, set your terminal font to a Nerd Font." >&2
    fi
  else
    if [[ $IS_DARWIN -eq 1 ]]; then
      if ls "$HOME/Library/Fonts" 2>/dev/null | grep -qi "JetBrains"; then
        echo "OK: Fonts present in ~/Library/Fonts (JetBrains)"
      else
        echo "Note: Unable to verify Nerd Font presence. If icons look like boxes, set your terminal font to a Nerd Font." >&2
      fi
    fi
  fi

  if [[ "$INSTALL_RUST" == "1" ]]; then
    if has cargo; then
      echo "OK: cargo -> $(command -v cargo)"
    else
      echo "MISSING: cargo" >&2
    fi
  fi

  if [[ "$INSTALL_GUI" == "1" ]]; then
    if [[ -d "$HOME/Applications/Kitty.app" ]]; then
      echo "OK: Kitty.app found in $HOME/Applications"
    elif [[ -d "/Applications/Kitty.app" ]]; then
      echo "OK: Kitty.app found in /Applications"
    else
      echo "MISSING: kitty" >&2
    fi
  fi

  echo
  echo "Next steps:"
  echo "  1) Open a new terminal session (zsh)"
  echo "  2) (Optional) Authenticate 1Password: op signin"
  echo "  3) (Optional) Configure kubectl access (kubeconfig)"
  echo "  4) Enable starship in zsh (add eval \"\$(starship init zsh)\" to your prompt config)"
}

main() {
  _h "Bootstrapping terminal environment"
  parse_args "$@"

  if [[ $IS_DARWIN -eq 1 ]]; then
    install_macos_packages
  else
    install_linux_packages
  fi

  install_rustup
  install_nerd_fonts
  install_claude
  setup_dotfiles
  ensure_tmux_tpm
  ensure_zsh_config
  ensure_zsh_default_shell
  post_checks
}

main "$@"