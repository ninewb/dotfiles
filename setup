#!/usr/bin/env bash
# shellcheck disable=SC2155,SC1091
set -euo pipefail

# ==============================================================================
# Dotfiles bootstrap (Linux + macOS)
#
# Goals (minimal, fast, and reproducible):
#   - kitty
#   - neovim
#   - tmux
#   - tmux plugin manager (tpm)
#   - nerd fonts (for glyphs/icons in tmux and prompt)
#   - 1password-cli (op)
#   - kubectl
#   - k9s
#   - cargo (rustup)
#   - stow
#   - zsh
#   - starship (prompt)
#
# Usage:
#   curl -fsSL https://raw.githubusercontent.com/ninewb/dotfiles/main/setup | bash
#   curl -fsSL "https://raw.githubusercontent.com/ninewb/dotfiles/main/setup?cachebust=$(date +%s)" | bash
#
# Optional env vars:
#   DOTFILES_REPO   (default: https://github.com/ninewb/dotfiles.git)
#   DOTFILES_DIR    (default: $HOME/.local/src/dotfiles)
#   STOW_PACKAGES   (default: "bin git neovim tmux zsh")
#   DO_STOW         (default: 1)  set to 0 to skip stow
#   INSTALL_CLAUDE   (default: 1)  set to 0 to skip Claude install
#   INSTALL_GUI     (default: 1)  set to 0 to skip GUI apps (e.g., Kitty on mac)
#   INSTALL_FONTS   (default: 1)  set to 0 to skip Nerd Fonts installation
#   INSTALL_1PW      (default: 1) set to 0 to skip 1Password CLI
#   INSTALL_KUBECTL  (default: 1) set to 0 to skip kubectl
#   INSTALL_K9S      (default: 1) set to 0 to skip k9s
#   INSTALL_RUST     (default: 1) set to 0 to skip rustup/cargo
#   INSTALL_STARSHIP (default: 1) set to 0 to skip starship
# ============================================================================== 

# -------- Pretty output --------
_hr() { printf '%*s\n' "${COLUMNS:-80}" '' | tr ' ' 'â”€'; }
_h() { printf "\n%s\n" "$( _hr )"; printf "%s\n" "$1"; printf "%s\n" "$( _hr )"; }

# -------- OS detection --------
OS="$(uname -s)"
ARCH="$(uname -m)"
IS_DARWIN=0
IS_LINUX=0
case "$OS" in
  Darwin) IS_DARWIN=1 ;;
  Linux)  IS_LINUX=1 ;;
  *) echo "Unsupported OS: $OS" >&2; exit 1 ;;
 esac

# -------- Defaults --------
: "${DOTFILES_REPO:=https://github.com/ninewb/dotfiles.git}"
: "${DOTFILES_DIR:=$HOME/.local/src/dotfiles}"
: "${STOW_PACKAGES:=bin git neovim tmux zsh}"
: "${DO_STOW:=1}"
: "${INSTALL_GUI:=1}"
: "${INSTALL_CLAUDE:=1}"
: "${INSTALL_FONTS:=1}"
: "${INSTALL_1PW:=1}"
: "${INSTALL_KUBECTL:=1}"
: "${INSTALL_K9S:=1}"
: "${INSTALL_RUST:=1}"
: "${INSTALL_STARSHIP:=1}"

# -------- Helpers --------
has() { command -v "$1" >/dev/null 2>&1; }
need_cmd() { has "$1" || { echo "Missing required command: $1" >&2; return 1; }; }

brew_ensure_formula() {
  local pkg="$1"
  if ! brew list --formula "$pkg" >/dev/null 2>&1; then
    echo "brew: install $pkg"
    brew install "$pkg"
    return 0
  fi

  if brew outdated --formula "$pkg" >/dev/null 2>&1; then
    # brew outdated exits 0 when there are outdated formulae matching
    if [[ -n "$(brew outdated --formula "$pkg")" ]]; then
      echo "brew: upgrade $pkg"
      brew upgrade "$pkg"
      return 0
    fi
  fi

  echo "brew: $pkg already up-to-date"
}

brew_ensure_cask() {
  local cask="$1"
  # casks are listed by token
  if ! brew list --cask "$cask" >/dev/null 2>&1; then
    echo "brew: install cask $cask"
    brew install --cask "$cask"
    return 0
  fi

  # For casks, `brew outdated --cask <name>` prints the name if outdated
  if [[ -n "$(brew outdated --cask "$cask" 2>/dev/null || true)" ]]; then
    echo "brew: upgrade cask $cask"
    brew upgrade --cask "$cask"
    return 0
  fi

  echo "brew: cask $cask already up-to-date"
}

ensure_brew_in_path() {
  if [[ $IS_DARWIN -eq 1 ]]; then
    if [[ -x /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -x /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  elif [[ $IS_LINUX -eq 1 ]]; then
    if [[ -x /home/linuxbrew/.linuxbrew/bin/brew ]]; then
      eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
    fi
  fi
}

# -------- Nerd Fonts installation --------
install_nerd_fonts() {
#
# -------- Claude CLI installation --------
install_claude() {
  [[ "${INSTALL_CLAUDE:-1}" == "1" ]] || return 0

  _h "Installing Claude (claude.ai)"

  need_cmd curl

  # Best-effort: avoid reinstall if already present
  if has claude; then
    echo "claude already present: $(command -v claude)"
    return 0
  fi

  # claude.ai installer is intended to be cross-platform (macOS + Linux)
  # Run in a subshell to avoid polluting current shell env.
  ( curl -fsSL https://claude.ai/install.sh | bash )
}
  [[ "${INSTALL_FONTS:-1}" == "1" ]] || return 0

  _h "Installing Nerd Fonts (glyphs/icons for tmux + prompt)"

  if [[ $IS_DARWIN -eq 1 ]]; then
    ensure_brew_in_path
    if ! has brew; then
      echo "Homebrew not found; cannot install fonts automatically." >&2
      return 0
    fi

    brew tap homebrew/cask-fonts >/dev/null 2>&1 || true

    # Widely compatible Nerd Font
    brew_ensure_cask font-jetbrains-mono-nerd-font

  elif [[ $IS_LINUX -eq 1 ]]; then
    local font_name="JetBrainsMono"
    local nf_version="3.2.1"
    local url="https://github.com/ryanoasis/nerd-fonts/releases/download/v${nf_version}/${font_name}.zip"

    need_cmd curl
    need_cmd unzip

    local font_dir="$HOME/.local/share/fonts"
    mkdir -p "$font_dir"

    local tmpdir
    tmpdir="$(mktemp -d)"

    echo "Downloading Nerd Font: ${font_name} (v${nf_version})"
    (
      cd "$tmpdir"
      curl -fsSLo "${font_name}.zip" "$url"
      unzip -o "${font_name}.zip" -d "$tmpdir" >/dev/null

      find "$tmpdir" -maxdepth 1 -type f \( -name '*.ttf' -o -name '*.otf' \) -print0 \
        | xargs -0 -I{} cp -f "{}" "$font_dir/"
    )

    rm -rf "$tmpdir"

    if has fc-cache; then
      fc-cache -f "$font_dir" >/dev/null 2>&1 || true
    else
      echo "Note: fc-cache not found. Install fontconfig and run: fc-cache -f" >&2
    fi
  fi
}

# -------- Zsh environment persistence (brew + cargo + sane config) --------
ensure_zsh_config() {
  _h "Configuring zsh environment (persist PATH, brew, cargo)"

  local zdot="$HOME/.config/zsh"
  mkdir -p "$zdot"

  local home_zshenv="$HOME/.zshenv"
  touch "$home_zshenv"
  if ! grep -q '^export ZDOTDIR=' "$home_zshenv"; then
    printf '\nexport ZDOTDIR="$HOME"/.config/zsh\n' >> "$home_zshenv"
  fi

  local zdot_zshenv="$zdot/.zshenv"
  touch "$zdot_zshenv"

  # Remove old/bad cargo env source if present
  if grep -q '"\$HOME/\.local/lib/cargo/env"' "$zdot_zshenv" 2>/dev/null; then
    perl -0777 -i -pe 's/^.*\"\$HOME\/.local\/lib\/cargo\/env\".*\n//mg' "$zdot_zshenv" || true
  fi

  # Ensure rustup cargo env is sourced if available
  if ! grep -q '^\.[[:space:]]\+"\$HOME/\.cargo/env"' "$zdot_zshenv" 2>/dev/null; then
    printf '\n# rustup/cargo (installed by setup)\nif [[ -f "$HOME/.cargo/env" ]]; then\n  . "$HOME/.cargo/env"\nfi\n' >> "$zdot_zshenv"
  fi

  # Ensure PATH basics are present for every zsh (including non-interactive shells)
  # Keep this simple and idempotent.
  local marker_begin="# >>> dotfiles PATH >>>"
  local marker_end="# <<< dotfiles PATH <<<"

  # Remove existing managed PATH block if present
  perl -0777 -i -pe "s/\n?\Q${marker_begin}\E.*?\Q${marker_end}\E\n?/\n/sg" "$zdot_zshenv" 2>/dev/null || true

  cat >> "$zdot_zshenv" <<'EOF'

# >>> dotfiles PATH >>>
# Base PATH hygiene (runs for every zsh)
typeset -U path PATH

# User bins first (stow targets ~/.local/bin)
path=(
  "$HOME/.local/bin"
  "$HOME/bin"
  "$HOME/.cargo/bin"
  $path
)

# System bins
path=(/usr/local/bin /usr/local/sbin $path)

# Homebrew / Linuxbrew
if [[ -d /opt/homebrew/bin ]]; then
  path=(/opt/homebrew/bin /opt/homebrew/sbin $path)
elif [[ -d /usr/local/bin ]]; then
  :
elif [[ -d /home/linuxbrew/.linuxbrew/bin ]]; then
  path=(/home/linuxbrew/.linuxbrew/bin /home/linuxbrew/.linuxbrew/sbin $path)
fi

export PATH
# <<< dotfiles PATH <<<
EOF

  local path_zsh="$zdot/00-path.zsh"
  if [[ ! -f "$path_zsh" ]]; then
    cat > "$path_zsh" <<'EOF'
# Base PATH hygiene for interactive shells
# - Ensure user bins are present
# - Prefer Homebrew paths on macOS (Apple Silicon vs Intel)
# - De-duplicate entries

typeset -U path PATH

# User bins first (so your stowed scripts like `k8s` resolve)
path=(
  "$HOME/.local/bin"
  "$HOME/bin"
  "$HOME/.cargo/bin"
  $path
)

# Homebrew / Linuxbrew
if [[ -d /opt/homebrew/bin ]]; then
  path=(/opt/homebrew/bin /opt/homebrew/sbin $path)
elif [[ -d /home/linuxbrew/.linuxbrew/bin ]]; then
  path=(/home/linuxbrew/.linuxbrew/bin /home/linuxbrew/.linuxbrew/sbin $path)
elif [[ -d /usr/local/bin ]]; then
  path=(/usr/local/bin /usr/local/sbin $path)
fi

export PATH
EOF
  fi

  local brew_zsh="$zdot/10-homebrew.zsh"
  if [[ ! -f "$brew_zsh" ]]; then
    cat > "$brew_zsh" <<'EOF'
# Homebrew PATH for interactive shells
if [[ -x /opt/homebrew/bin/brew ]]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ -x /usr/local/bin/brew ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
fi
EOF
  fi

  local cargo_zsh="$zdot/20-cargo.zsh"
  if [[ ! -f "$cargo_zsh" ]]; then
    cat > "$cargo_zsh" <<'EOF'
# Cargo PATH for interactive shells
export PATH="$HOME/.cargo/bin:$PATH"
EOF
  fi

  local zprofile="$zdot/.zprofile"
  if [[ ! -f "$zprofile" ]]; then
    cat > "$zprofile" <<'EOF'
# Login shell environment
if [[ -x /opt/homebrew/bin/brew ]]; then
  eval "$(/opt/homebrew/bin/brew shellenv)"
elif [[ -x /usr/local/bin/brew ]]; then
  eval "$(/usr/local/bin/brew shellenv)"
elif [[ -x /home/linuxbrew/.linuxbrew/bin/brew ]]; then
  eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi
EOF
  fi

  local zshrc="$zdot/.zshrc"
  local desired_zshrc
  desired_zshrc=$'for config in "$HOME"/.config/zsh/*.zsh(N); do\n  [[ -r "$config" ]] && source "$config"\ndone\n'

  if [[ -f "$zshrc" ]]; then
    # If the file contains the old one-liner OR an incorrect absolute path, replace it.
    if grep -qE '^for[[:space:]]+config[[:space:]]*\(|/\.config/zsh/\*\.zsh' "$zshrc"; then
      printf '%s' "$desired_zshrc" > "$zshrc"
    else
      # If it doesn't already contain a *.zsh sourcing loop, append a managed loop.
      if ! grep -qE '\.config/zsh/\*\.zsh' "$zshrc"; then
        printf '\n%s' "$desired_zshrc" >> "$zshrc"
      fi
    fi
  else
    printf '%s' "$desired_zshrc" > "$zshrc"
  fi
}

# -------- Package installation --------
install_macos_packages() {
  _h "macOS: installing packages (Homebrew)"

  # If brew exists but isn't on PATH yet, load it first.
  ensure_brew_in_path

  if ! has brew; then
    echo "Homebrew not found in PATH. Checking standard locations..."
    if [[ -x /opt/homebrew/bin/brew ]]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -x /usr/local/bin/brew ]]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  fi

  if ! has brew; then
    echo "Homebrew not found. Installing..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    ensure_brew_in_path
  fi

  brew update

  # Install/upgrade formulae individually to avoid noisy "already installed" warnings
  brew_ensure_formula git
  brew_ensure_formula stow
  brew_ensure_formula neovim
  brew_ensure_formula tmux
  brew_ensure_formula zsh
  brew_ensure_formula jq
  brew_ensure_formula fzf
  if [[ "$INSTALL_STARSHIP" == "1" ]]; then
    brew_ensure_formula starship
  fi

  # Homebrew's python token currently maps to a versioned formula (e.g., python@3.x)
  # Ensuring "python" keeps it current.
  brew_ensure_formula python

  if [[ "$INSTALL_1PW" == "1" ]]; then
    brew_ensure_formula 1password-cli
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    brew_ensure_formula kubectl
  fi

  if [[ "$INSTALL_K9S" == "1" ]]; then
    brew_ensure_formula k9s
  fi

  if [[ "$INSTALL_GUI" == "1" ]]; then
    # Install Kitty (terminal emulator)
    brew_ensure_cask kitty

    # Best-effort: ensure app exists in standard macOS locations
    if [[ -d "$HOME/Applications/Kitty.app" ]]; then
      :
    elif [[ -d "/Applications/Kitty.app" ]]; then
      :
    elif [[ -d "$(brew --prefix)/Caskroom/kitty" ]]; then
      local app_src
      app_src="$(ls -1d "$(brew --prefix)"/Caskroom/kitty/*/Kitty.app 2>/dev/null | tail -n 1 || true)"
      if [[ -n "$app_src" ]]; then
        mkdir -p "$HOME/Applications"
        rsync -a "$app_src" "$HOME/Applications/" >/dev/null 2>&1 || true
      fi
    fi
  fi
}

install_linux_packages() {
  _h "Linux: installing packages (apt)"

  # Prefer Ubuntu/Debian apt-based flows.
  need_cmd apt-get

  sudo apt-get update -y

  # Keep existing packages current before installing new ones
  sudo apt-get upgrade -y
  sudo apt-get install -y --no-install-recommends \
    ca-certificates \
    curl \
    unzip \
    fontconfig \
    git \
    gnupg \
    jq \
    locales \
    stow \
    tmux \
    neovim \
    zsh \
    fzf \
    python3 \
    python3-pip \
    k9s \
    starship

  if [[ "$INSTALL_STARSHIP" == "1" ]]; then
    if ! has starship; then
      _h "Linux: installing starship (fallback script)"
      curl -fsSL https://starship.rs/install.sh | sh -s -- -y
    fi
  fi

  if [[ "$INSTALL_K9S" == "1" ]]; then
    if ! has k9s; then
      _h "Linux: installing k9s (fallback binary)"
      # Install latest k9s release binary (best-effort)
      local k9s_os="Linux"
      local k9s_arch="amd64"
      case "$(uname -m)" in
        x86_64|amd64) k9s_arch="amd64" ;;
        aarch64|arm64) k9s_arch="arm64" ;;
      esac

      local tmpdir
      tmpdir="$(mktemp -d)"
      (
        cd "$tmpdir"
        curl -fsSLO "https://github.com/derailed/k9s/releases/latest/download/k9s_${k9s_os}_${k9s_arch}.tar.gz"
        tar -xzf "k9s_${k9s_os}_${k9s_arch}.tar.gz"
        sudo install -m 0755 k9s /usr/local/bin/k9s
      )
      rm -rf "$tmpdir"
    fi
  fi

  # Kitty availability varies by distro; try apt first.
  if [[ "$INSTALL_GUI" == "1" ]]; then
    if ! dpkg -s kitty >/dev/null 2>&1; then
      sudo apt-get install -y kitty || true
    fi
  fi

  if [[ "$INSTALL_1PW" == "1" ]]; then
    if ! has op; then
      _h "Linux: installing 1Password CLI (op)"
      # 1Password official repo install (Debian/Ubuntu)
      sudo mkdir -p /etc/apt/keyrings
      curl -fsSL https://downloads.1password.com/linux/keys/1password.asc \
        | sudo gpg --dearmor --yes -o /etc/apt/keyrings/1password-archive-keyring.gpg

      # Determine codename (fallback to jammy)
      local codename=""
      codename="$(. /etc/os-release && echo "${VERSION_CODENAME:-}")"
      if [[ -z "$codename" ]]; then codename="jammy"; fi

      echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/1password-archive-keyring.gpg] https://downloads.1password.com/linux/debian/$(dpkg --print-architecture) stable main" \
        | sudo tee /etc/apt/sources.list.d/1password.list >/dev/null

      sudo apt-get update -y
      sudo apt-get install -y 1password-cli
    fi
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    _h "Linux: ensuring kubectl"
    if ! has kubectl; then
      # Install latest stable kubectl
      local ver
      ver="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
      curl -fsSLO "https://dl.k8s.io/release/${ver}/bin/linux/amd64/kubectl"
      sudo install -m 0755 kubectl /usr/local/bin/kubectl
      rm -f kubectl
    fi
  fi
}

# -------- Rust / Cargo --------
install_rustup() {
  [[ "$INSTALL_RUST" == "1" ]] || return 0

  _h "Installing Rust (rustup/cargo)"

  if has cargo; then
    echo "cargo already present: $(command -v cargo)"
    return 0
  fi

  # rustup installs into ~/.cargo and ~/.rustup by default
  curl -fsSL https://sh.rustup.rs | sh -s -- -y --profile default --default-toolchain stable

  # Ensure current shell sees cargo for the rest of the script
  export PATH="$HOME/.cargo/bin:$PATH"
}

# -------- Zsh as default shell --------
ensure_zsh_default_shell() {
  _h "Ensuring zsh is the default shell"

  if ! has zsh; then
    echo "zsh not installed; skipping default shell change." >&2
    return 0
  fi

  # macOS: chsh is fine; Linux: may require sudo depending on environment
  local zsh_path="$(command -v zsh)"

  # Ensure zsh is listed in /etc/shells on Linux
  if [[ $IS_LINUX -eq 1 ]]; then
    if ! grep -qx "$zsh_path" /etc/shells; then
      echo "$zsh_path" | sudo tee -a /etc/shells >/dev/null
    fi
  fi

  if [[ "${SHELL:-}" != "$zsh_path" ]]; then
    echo "Changing default shell to: $zsh_path"
    chsh -s "$zsh_path" || true
  fi
}

ensure_tmux_tpm() {
  _h "Ensuring tmux plugin manager (tpm)"

  local tpm_dir="$HOME/.tmux/plugins/tpm"

  # Ensure parent dir exists
  mkdir -p "$(dirname "$tpm_dir")"

  # Clone or update
  if [[ -d "$tpm_dir/.git" ]]; then
    echo "tpm already present: $tpm_dir"
    ( cd "$tpm_dir" && git pull --ff-only ) || echo "Warning: unable to update tpm; continuing" >&2
  else
    echo "Installing tpm to: $tpm_dir"
    git clone https://github.com/tmux-plugins/tpm "$tpm_dir"
  fi

  # Best-effort: if tmux is running, install plugins immediately; otherwise user can do it later.
  if has tmux; then
    if tmux list-sessions >/dev/null 2>&1; then
      echo "tmux session detected; attempting to install plugins via tpm..."
      "$tpm_dir/bin/install_plugins" || true
      "$tpm_dir/bin/update_plugins" all || true
    else
      echo "No tmux session detected. After starting tmux, install plugins with: prefix + I"
    fi
  fi
}

# -------- Dotfiles clone + stow --------
setup_dotfiles() {
  _h "Cloning dotfiles"

  mkdir -p "$(dirname "$DOTFILES_DIR")"

  if [[ -d "$DOTFILES_DIR/.git" ]]; then
    echo "Dotfiles already cloned: $DOTFILES_DIR"
    echo "Updating dotfiles (git pull --ff-only)..."
    ( cd "$DOTFILES_DIR" && git pull --ff-only ) || echo "Warning: unable to fast-forward update dotfiles repo; continuing" >&2
  else
    git clone "$DOTFILES_REPO" "$DOTFILES_DIR"
  fi

  # Print current dotfiles revision for troubleshooting
  ( cd "$DOTFILES_DIR" && echo "Dotfiles revision: $(git rev-parse --short HEAD)" ) || true

  if [[ "$DO_STOW" == "1" ]]; then
    _h "Stowing packages (skipping missing): $STOW_PACKAGES"

    # Stow each package individually; skip if the package directory does not exist
    local pkg
    for pkg in $STOW_PACKAGES; do
      if [[ -d "$DOTFILES_DIR/$pkg" ]]; then
        echo "stow: $pkg"
        # Use --restow so reruns refresh symlinks; use -v to show conflicts clearly.
        ( cd "$DOTFILES_DIR" && stow -v --restow "$pkg" -t "$HOME" ) || echo "stow: package '$pkg' had conflicts; skipping" >&2
      else
        echo "stow: skipping missing package '$pkg' (no directory at $DOTFILES_DIR/$pkg)" >&2
      fi
    done

    # Quick verification (helps diagnose stow conflicts)
    if [[ -d "$DOTFILES_DIR/zsh/.config/zsh" ]]; then
      echo "Repo zsh files:" 
      ls -la "$DOTFILES_DIR/zsh/.config/zsh" || true
    fi

    echo "Home zsh config after stow:" 
    ls -la "$HOME/.config/zsh" || true
  else
    echo "Skipping stow (DO_STOW=0)"
  fi

  # Ensure ZDOTDIR is consistent with your repo expectation
  # Only add if not already present
  local zshenv=""
  if [[ $IS_DARWIN -eq 1 ]]; then
    zshenv="$HOME/.zshenv"
  else
    # System zshenv is common on Linux; keep user-scoped and non-root
    zshenv="$HOME/.zshenv"
  fi

  if [[ ! -f "$zshenv" ]] || ! grep -q 'export ZDOTDIR=' "$zshenv"; then
    echo 'export ZDOTDIR="$HOME"/.config/zsh' >> "$zshenv"
  fi
}

# -------- Alacritty config sanity --------
post_checks() {
  _h "Post-install checks"

  echo "OS: $OS ($ARCH)"

  echo "PATH: $PATH"
  if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
    echo "Note: $HOME/.local/bin is not on PATH (your stowed bin scripts may not resolve)." >&2
  fi

  for c in git stow nvim tmux zsh python3 pip3 kubectl k9s starship; do
    if has "$c"; then
      echo "OK: $c -> $(command -v "$c")"
    else
      echo "MISSING: $c" >&2
    fi
  done

  # TPM check
  if [[ -x "$HOME/.tmux/plugins/tpm/tpm" ]]; then
    echo "OK: tpm -> $HOME/.tmux/plugins/tpm/tpm"
  else
    echo "MISSING: tpm (tmux plugin manager)" >&2
  fi

  # Nerd Fonts check (best-effort)
  if has fc-list; then
    if fc-list | grep -qi "JetBrainsMono Nerd Font"; then
      echo "OK: Nerd Font detected (JetBrainsMono Nerd Font)"
    else
      echo "Note: Nerd Font not detected via fc-list. If icons look like boxes, set your terminal font to a Nerd Font." >&2
    fi
  else
    if [[ $IS_DARWIN -eq 1 ]]; then
      if ls "$HOME/Library/Fonts" 2>/dev/null | grep -qi "JetBrains"; then
        echo "OK: Fonts present in ~/Library/Fonts (JetBrains)"
      else
        echo "Note: Unable to verify Nerd Font presence. If icons look like boxes, set your terminal font to a Nerd Font." >&2
      fi
    fi
  fi

  if [[ "$INSTALL_1PW" == "1" ]]; then
    if has op; then
      echo "OK: op -> $(command -v op)"
      echo "Note: run 'op signin' manually to authenticate."
    else
      echo "MISSING: op (1Password CLI)" >&2
    fi
  fi

  if [[ "$INSTALL_KUBECTL" == "1" ]]; then
    if has kubectl; then
      echo "OK: kubectl -> $(command -v kubectl)"
    else
      echo "MISSING: kubectl" >&2
    fi
  fi

  if [[ "$INSTALL_RUST" == "1" ]]; then
    if has cargo; then
      echo "OK: cargo -> $(command -v cargo)"
    else
      echo "MISSING: cargo" >&2
    fi
  fi

  if [[ "$INSTALL_CLAUDE" == "1" ]]; then
    if has claude; then
      echo "OK: claude -> $(command -v claude)"
    else
      echo "MISSING: claude (Claude CLI)" >&2
    fi
  fi

  if [[ "$INSTALL_GUI" == "1" ]]; then
    if has kitty; then
      echo "OK: kitty -> $(command -v kitty)"
    elif [[ -d "$HOME/Applications/Kitty.app" ]]; then
      echo "OK: Kitty.app found in $HOME/Applications"
    elif [[ -d "/Applications/Kitty.app" ]]; then
      echo "OK: Kitty.app found in /Applications"
    else
      echo "MISSING: kitty" >&2
    fi
  fi

  echo
  echo "Next steps:"
  echo "  1) Open a new terminal session (zsh)"
  echo "  2) (Optional) Authenticate 1Password: op signin"
  echo "  3) (Optional) Configure kubectl access (kubeconfig)"
  echo "  4) Enable starship in zsh (add eval \"\$(starship init zsh)\" to your prompt config)"
}

main() {
  _h "Bootstrapping terminal environment"

  if [[ $IS_DARWIN -eq 1 ]]; then
    install_macos_packages
  else
    install_linux_packages
  fi

  install_rustup
  install_nerd_fonts
  install_claude
  setup_dotfiles
  ensure_tmux_tpm
  ensure_zsh_config
  ensure_zsh_default_shell
  post_checks
}

main "$@"