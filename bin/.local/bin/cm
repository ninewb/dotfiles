#!/usr/bin/env bash
set -euo pipefail
# cm: kubeconfig/context manager

CM_KUBECONFIG_DEFAULT="${CM_KUBECONFIG:-${KUBECONFIG:-$HOME/.kube/config}}"

usage() {
  cat <<'EOF'
Usage:
  KUBERNETES CONTEXT MANAGER
  cm [--kubeconfig <path>] <command> [args]

Commands:
  add <resource>                                  Add AKS credentials/context for <resource> (default: azure)
  add azure <resource>                            Add AKS credentials/context for <resource>
  add aws <cluster> <region> [alias]              Add EKS credentials/context (optional context alias)
  add gcp <cluster> <location> <project> [alias]  Add GKE credentials/context (location is region or zone; optional context alias)
  list                                            List contexts (kubectl config get-contexts)
  use [<context>]                                 Switch current context (interactive if no context)
  current                                         Print current context
  delete [<context>]                              Delete a context and its associated cluster/user from kubeconfig (interactive if no context)

Notes:
  - If CM_KUBECONFIG is set, it is used.
  - Otherwise KUBECONFIG is used.
  - Otherwise defaults to ~/.kube/config
  - For Azure (AKS), <resource> is the base name used to derive the resource group and cluster: <resource>-rg and <resource>-aks.

Examples:
  cm add my-awesome-resource
  cm add azure my-awesome-resource
  cm list
  cm use my-awesome-resource
  cm add aws prod-eks us-east-1 aws-prod-eks
  cm add gcp analytics-cluster us-central1 my-project gcp-analytics
  cm delete
EOF
}

err() { echo "cm: $*" >&2; }

die() { err "$*"; exit 1; }

require() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

_lc() { printf '%s' "$1" | tr '[:upper:]' '[:lower:]'; }

# Filter items by a case-insensitive substring.
# Usage: filter_items <needle> <items...>
# Prints matching items, one per line.
filter_items() {
  local needle="$1"; shift
  local n_lc
  n_lc="$(_lc "$needle")"

  local it
  for it in "$@"; do
    if [[ -z "$needle" ]]; then
      printf '%s\n' "$it"
    else
      local it_lc
      it_lc="$(_lc "$it")"
      if [[ "$it_lc" == *"$n_lc"* ]]; then
        printf '%s\n' "$it"
      fi
    fi
  done
}

# Read a single line from /dev/tty if possible (so selection works even when stdout is piped)
read_tty_line() {
  local line=""
  if [[ -r /dev/tty ]]; then
    IFS= read -r line < /dev/tty
  else
    IFS= read -r line
  fi
  printf '%s' "$line"
}

# Minimal portable selector with filtering.
# Prints the selected item.
# Behavior:
# - User can type a filter string to narrow results.
# - Then choose by number.
# - Enter on empty filter shows all.
# - Enter on empty selection cancels.
select_one_tui() {
  local title="$1"; shift
  local -a items=("$@")

  local count="${#items[@]}"
  (( count == 0 )) && die "No items to choose from"

  local filter=""
  while true; do
    echo "$title" >&2
    echo "Filter (substring, Enter for all, or type 'q' to cancel): " >&2
    printf '> ' >&2
    filter="$(read_tty_line)"
    [[ "$filter" == "q" ]] && return 1

    local -a filtered=()
    if [[ -z "$filter" ]]; then
      filtered=("${items[@]}")
    else
      read_lines_into_array filtered < <(filter_items "$filter" "${items[@]}")
    fi

    if (( ${#filtered[@]} == 0 )); then
      echo "No matches. Try again." >&2
      echo >&2
      continue
    fi

    echo >&2
    print_numbered "${filtered[@]}" >&2
    echo >&2
    echo "Enter a number to select, 'r' to refine filter, or Enter to cancel." >&2
    printf '> ' >&2
    local sel
    sel="$(read_tty_line)"

    [[ -z "$sel" ]] && return 1
    [[ "$sel" == "r" ]] && { echo >&2; continue; }

    if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
      echo "Invalid selection: $sel" >&2
      echo >&2
      continue
    fi

    local idx=$((sel-1))
    if (( idx < 0 || idx >= ${#filtered[@]} )); then
      echo "Selection out of range: $sel" >&2
      echo >&2
      continue
    fi

    printf '%s\n' "${filtered[$idx]}"
    return 0
  done
}


# Bash 3.2 compatibility: `mapfile` is not available on macOS.
# Read lines from stdin into a named array variable.
read_lines_into_array() {
  local __arr_name="$1"
  # shellcheck disable=SC2034
  local __line

  # Clear the array
  eval "$__arr_name=()"

  if command -v mapfile >/dev/null 2>&1; then
    # Bash 4+
    mapfile -t "$__arr_name"
    return 0
  fi

  # Bash 3.2 fallback
  while IFS= read -r __line; do
    eval "$__arr_name+=(\"$__line\")"
  done
}

# Capture the output of a command into a named array (one item per line).
cmd_to_array() {
  local __arr_name="$1"; shift
  # Use process substitution to feed into read_lines_into_array
  read_lines_into_array "$__arr_name" < <("$@")
}


# Run kubectl against a specific kubeconfig, without forcing users to export env vars.
kubectl_cfg() {
  local kubeconfig="$1"; shift
  KUBECONFIG="$kubeconfig" kubectl "$@"
}

# Read a single line from the user with a prompt.
prompt() {
  local msg="$1"
  local line=""

  # Always print prompt to stderr so it shows up even if stdout is being piped.
  printf '%s' "$msg" >&2

  if [[ -t 0 ]]; then
    IFS= read -r line
  elif [[ -r /dev/tty ]]; then
    IFS= read -r line < /dev/tty
  else
    # Last resort: read from stdin (may block if truly non-interactive)
    IFS= read -r line
  fi

  printf '%s' "$line"
}

# Render a numbered list of items
print_numbered() {
  local -a items=("$@")
  local i
  for i in "${!items[@]}"; do
    printf '%3d) %s\n' "$((i+1))" "${items[$i]}"
  done
}



choose_one() {
  local title="$1"; shift
  local -a items=("$@")
  select_one_tui "$title" "${items[@]}"
}

list_contexts() {
  local kubeconfig="$1"
  kubectl_cfg "$kubeconfig" config get-contexts
}

list_context_names() {
  local kubeconfig="$1"
  kubectl_cfg "$kubeconfig" config get-contexts -o name
}

list_cluster_names() {
  local kubeconfig="$1"
  kubectl_cfg "$kubeconfig" config get-clusters
}

get_context_cluster() {
  local kubeconfig="$1"
  local ctx="$2"
  kubectl_cfg "$kubeconfig" config view -o jsonpath="{.contexts[?(@.name=='${ctx}')].context.cluster}"
}

get_context_user() {
  local kubeconfig="$1"
  local ctx="$2"
  kubectl_cfg "$kubeconfig" config view -o jsonpath="{.contexts[?(@.name=='${ctx}')].context.user}"
}

count_other_context_refs_cluster() {
  local kubeconfig="$1"
  local target_ctx="$2"
  local cluster="$3"

  local line
  local count=0
  # Output format: ctx<TAB>cluster
  while IFS=$'\t' read -r line; do
    local ctx="${line%%$'\t'*}"
    local cl="${line#*$'\t'}"
    [[ "$ctx" == "$target_ctx" ]] && continue
    [[ "$cl" == "$cluster" ]] && count=$((count+1))
  done < <(kubectl_cfg "$kubeconfig" config view -o jsonpath='{range .contexts[*]}{.name}{"\t"}{.context.cluster}{"\n"}{end}')

  echo "$count"
}

count_other_context_refs_user() {
  local kubeconfig="$1"
  local target_ctx="$2"
  local user="$3"

  local line
  local count=0
  # Output format: ctx<TAB>user
  while IFS=$'\t' read -r line; do
    local ctx="${line%%$'\t'*}"
    local u="${line#*$'\t'}"
    [[ "$ctx" == "$target_ctx" ]] && continue
    [[ "$u" == "$user" ]] && count=$((count+1))
  done < <(kubectl_cfg "$kubeconfig" config view -o jsonpath='{range .contexts[*]}{.name}{"\t"}{.context.user}{"\n"}{end}')

  echo "$count"
}

rename_context_best_effort() {
  local kubeconfig="$1"
  local desired="$2"

  [[ -z "$desired" ]] && return 0

  # Best-effort rename of current context to a friendly name.
  local current
  current="$(kubectl_cfg "$kubeconfig" config current-context 2>/dev/null || true)"
  if [[ -n "$current" && "$current" != "$desired" ]]; then
    if ! kubectl_cfg "$kubeconfig" config get-contexts -o name | grep -qx "$desired"; then
      err "Renaming context '$current' -> '$desired'"
      kubectl_cfg "$kubeconfig" config rename-context "$current" "$desired" || true
    fi
  fi
}

cmd_add_azure() {
  local kubeconfig="$1"
  local resource="$2"

  require az

  # Convention:
  #   Resource Group: <resource>-rg
  #   AKS Name:       <resource>-aks
  # Context name should be <resource> (helps when you have many).
  #
  # Note: `az aks get-credentials` will merge into the provided kubeconfig.
  err "Adding AKS credentials for resource='$resource' into kubeconfig: $kubeconfig"

  # Ensure kubeconfig directory exists.
  mkdir -p "$(dirname "$kubeconfig")"

  az aks get-credentials \
    --resource-group "${resource}-rg" \
    --name "${resource}-aks" \
    --file "$kubeconfig" \
    --overwrite-existing

  rename_context_best_effort "$kubeconfig" "$resource"
  err "Done. Current context: $(kubectl_cfg "$kubeconfig" config current-context)"
}

cmd_add_aws() {
  local kubeconfig="$1"
  local cluster="$2"
  local region="$3"
  local alias="${4:-}"

  require aws

  err "Adding EKS credentials for cluster='$cluster' region='$region' into kubeconfig: $kubeconfig"

  # Ensure kubeconfig directory exists.
  mkdir -p "$(dirname "$kubeconfig")"

  if [[ -n "$alias" ]]; then
    aws eks update-kubeconfig \
      --name "$cluster" \
      --region "$region" \
      --kubeconfig "$kubeconfig" \
      --alias "$alias"
    rename_context_best_effort "$kubeconfig" "$alias"
  else
    aws eks update-kubeconfig \
      --name "$cluster" \
      --region "$region" \
      --kubeconfig "$kubeconfig"
  fi

  err "Done. Current context: $(kubectl_cfg "$kubeconfig" config current-context)"
}

cmd_add_gcp() {
  local kubeconfig="$1"
  local cluster="$2"
  local location="$3"   # region (e.g. us-central1) OR zone (e.g. us-central1-a)
  local project="$4"
  local alias="${5:-}"

  require gcloud

  err "Adding GKE credentials for cluster='$cluster' location='$location' project='$project' into kubeconfig: $kubeconfig"

  # Ensure kubeconfig directory exists.
  mkdir -p "$(dirname "$kubeconfig")"

  # gcloud does not have a direct --kubeconfig flag; it respects KUBECONFIG.
  # Heuristic: zones typically end with a trailing -[a-z] (e.g. us-central1-a).
  if [[ "$location" =~ -[a-z]$ ]]; then
    KUBECONFIG="$kubeconfig" gcloud container clusters get-credentials "$cluster" \
      --zone "$location" \
      --project "$project"
  else
    KUBECONFIG="$kubeconfig" gcloud container clusters get-credentials "$cluster" \
      --region "$location" \
      --project "$project"
  fi

  if [[ -n "$alias" ]]; then
    rename_context_best_effort "$kubeconfig" "$alias"
  fi

  err "Done. Current context: $(kubectl_cfg "$kubeconfig" config current-context)"
}

cmd_add() {
  local kubeconfig="$1"
  shift

  # Back-compat:
  #   cm add <resource>           -> azure
  #   cm add azure <resource>
  #   cm add aws <cluster> <region> [alias]
  #   cm add gcp <cluster> <location> <project> [alias]

  local provider="${1:-}"

  case "$provider" in
    azure)
      [[ $# -lt 2 ]] && die "add azure requires <resource>"
      cmd_add_azure "$kubeconfig" "$2"
      ;;
    aws)
      [[ $# -lt 3 ]] && die "add aws requires <cluster> <region> [alias]"
      cmd_add_aws "$kubeconfig" "$2" "$3" "${4:-}"
      ;;
    gcp)
      [[ $# -lt 4 ]] && die "add gcp requires <cluster> <location> <project> [alias]"
      cmd_add_gcp "$kubeconfig" "$2" "$3" "$4" "${5:-}"
      ;;
    *)
      # Default to azure resource if provider is not recognized.
      [[ $# -lt 1 ]] && die "add requires <resource>"
      cmd_add_azure "$kubeconfig" "$provider"
      ;;
  esac
}

cmd_list() {
  local kubeconfig="$1"
  list_contexts "$kubeconfig"
}

cmd_use() {
  local kubeconfig="$1"
  local ctx="${2:-}"

  if [[ -z "$ctx" ]]; then
    cmd_to_array contexts list_context_names "$kubeconfig"
    if (( ${#contexts[@]} == 0 )); then
      die "No contexts found"
    fi

    if ! ctx="$(choose_one "Select context to use:" "${contexts[@]}")"; then
      err "Cancelled"
      return 1
    fi
  fi

  # Ensure context exists.
  if ! kubectl_cfg "$kubeconfig" config get-contexts -o name | grep -qx "$ctx"; then
    die "Context not found: $ctx"
  fi

  kubectl_cfg "$kubeconfig" config use-context "$ctx"
}

cmd_current() {
  local kubeconfig="$1"
  kubectl_cfg "$kubeconfig" config current-context
}



cmd_delete() {
  local kubeconfig="$1"
  local ctx="${2:-}"

  # If no context provided, choose interactively.
  if [[ -z "$ctx" ]]; then
    cmd_to_array contexts list_context_names "$kubeconfig"
    if (( ${#contexts[@]} == 0 )); then
      die "No contexts found"
    fi

    if ! ctx="$(choose_one "Select context to delete:" "${contexts[@]}")"; then
      err "Cancelled"
      return 1
    fi
  fi

  # Ensure context exists.
  if ! kubectl_cfg "$kubeconfig" config get-contexts -o name | grep -qx "$ctx"; then
    die "Context not found: $ctx"
  fi

  local cluster user
  cluster="$(get_context_cluster "$kubeconfig" "$ctx" || true)"
  user="$(get_context_user "$kubeconfig" "$ctx" || true)"

  # Determine whether cluster/user are referenced by other contexts.
  local cluster_refs user_refs
  cluster_refs=0
  user_refs=0
  if [[ -n "$cluster" ]]; then
    cluster_refs="$(count_other_context_refs_cluster "$kubeconfig" "$ctx" "$cluster")"
  fi
  if [[ -n "$user" ]]; then
    user_refs="$(count_other_context_refs_user "$kubeconfig" "$ctx" "$user")"
  fi

  echo "About to delete from kubeconfig: $kubeconfig"
  echo "  - context: $ctx"
  if [[ -n "$cluster" ]]; then
    if [[ "$cluster_refs" == "0" ]]; then
      echo "  - cluster: $cluster (will be removed)"
    else
      echo "  - cluster: $cluster (kept; referenced by $cluster_refs other context(s))"
    fi
  else
    echo "  - cluster: <unknown>"
  fi

  if [[ -n "$user" ]]; then
    if [[ "$user_refs" == "0" ]]; then
      echo "  - user:    $user (will be removed)"
    else
      echo "  - user:    $user (kept; referenced by $user_refs other context(s))"
    fi
  else
    echo "  - user:    <unknown>"
  fi
  echo

  local confirm
  confirm="$(prompt "Type 'yes' to confirm: ")"
  echo
  [[ "$confirm" != "yes" ]] && { err "Aborted"; return 1; }

  # Delete context first.
  err "Deleting context: $ctx"
  kubectl_cfg "$kubeconfig" config delete-context "$ctx"

  # Delete cluster if no longer referenced.
  if [[ -n "$cluster" && "$cluster_refs" == "0" ]]; then
    err "Deleting cluster: $cluster"
    kubectl_cfg "$kubeconfig" config delete-cluster "$cluster" || true
  fi

  # Delete user if no longer referenced.
  if [[ -n "$user" && "$user_refs" == "0" ]]; then
    err "Deleting user: $user"
    # kubectl has delete-user, but older versions may not; fallback to unset.
    if kubectl_cfg "$kubeconfig" config --help 2>/dev/null | grep -q "delete-user"; then
      kubectl_cfg "$kubeconfig" config delete-user "$user" || true
    else
      kubectl_cfg "$kubeconfig" config unset "users.${user}" || true
    fi
  fi

  err "Done."
}


main() {
  require kubectl

  local kubeconfig="$CM_KUBECONFIG_DEFAULT"

  # Simple arg parsing for --kubeconfig / -k
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -k|--kubeconfig)
        [[ $# -lt 2 ]] && die "Missing value for $1"
        kubeconfig="$2"
        shift 2
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        break
        ;;
    esac
  done

  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    add)
      [[ $# -lt 1 ]] && die "add requires <resource> OR <provider> ... (use --help)"
      cmd_add "$kubeconfig" "$@"
      ;;
    list|get-contexts)
      cmd_list "$kubeconfig"
      ;;
    use)
      # If no <context> is provided, cmd_use will prompt interactively.
      cmd_use "$kubeconfig" "${1:-}"
      ;;
    current)
      cmd_current "$kubeconfig"
      ;;
    delete)
      cmd_delete "$kubeconfig" "${1:-}"
      ;;
    "")
      usage
      exit 1
      ;;
    *)
      die "Unknown command: $cmd (use --help)"
      ;;
  esac
}

main "$@"